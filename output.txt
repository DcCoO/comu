 /\ (Q -> R)) <-> ((P \/ Q) -> R).
Proof.
split.
- intros.
  destruct H.
  destruct H0.
  + apply H  /\ (Q -> R)) <-> ((P \/ Q) -> R).
Proof.
split.
- intros.
  destruct H.
  destruct H0.
  + apply H  /\ (Q -> R)) <-> ((P \/ Q) -> R).
Proof.
split.
- intros.
  destruct H.
  destruct H0.
  + apply H  /\ (Q -> R)) <-> ((P \/ Q) -> R).
Proof.
split.
- intros.
  destruct H.
  destruct H0.
  + apply H  /\ (Q -> R)) <-> ((P \/ Q) -> R).
Proof.
split.
- intros.
  destruct H.
  destruct H0.
  + apply H  /\ (Q -> R)) <-> ((P \/ Q) -> R).
Proof.
split.
- intros.
  destruct H.
  destruct H0.
  + apply H  /\ (Q -> R)) <-> ((P \/ Q) -> R).
Proof.
split.
- intros.
  destruct H.
  destruct H0.
  + apply H  /\ (Q -> R)) <-> ((P \/ Q) -> R).
Proof.
split.
- intros.
  destruct H.
  destruct H0.
  + apply H t.
Require Import Coq.Arith.Plus.
Require Import Coq.Init.Nat.
Import ListNotations.

(** Um dicion√o valor associado √†
    chave √© uma string. Aqui, estamos
    representando um dicion√°rio como
  o valor associado √†
    chave √© uma string. Aqui, estamos
    representando um dicion√°rio como
  o valor associado √†
    chave √© uma string. Aqui, estamos
    representando um dicion√°rio como
  o 4 *)
(** Defina uma fun√ß√£o [insert] que, dada uma
    chave [k], um valor [v] e um dicion√°rio [],
      a fun√ß√£o atualiza o mapeamento para [v];
    - se n√£o existir uma entrada mapeada em [k]