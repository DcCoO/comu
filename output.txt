
(** * TAES -- EXERCÍCIO ESCOLAR (2018.2) *)

(** Aluno: ______________________________ *)

(** _Não_ é permitido fazer uso de táticas de
    "automação", como [auto], [tauto],
    [omega], etc.
    
    _Não_ é permitido fazer uso de teoremas
    provados anteriormente, exceto se indicado
    pela questão. *)

(** ** PARTE 1 -- LÓGICA *)

(** **** {1,0 pt.} Questão 1 *)
(** Prove o seguinte teorema. *)
Theorem imp_trans :
  forall (P Q R : Prop),
    ((P -> Q) /\ (Q -> R)) -> (P -> R).
Proof. 
intros.
destruct H.
apply H in H0.
apply H1 in H0.
apply H0.
Qed.


(** **** {2,0 pt.} Questão 2 *)
(** Prove o seguinte teorema. *)
Theorem imp_or :
  forall (P Q R : Prop),
    ((P -> R) /\ (Q -> R)) <-> ((P \/ Q) -> R).
Proof.
split.
- intros.
  destruct H.
  destruct H0.
  + apply H in H0.
    apply H0.
  + apply H1 in H0.
    apply H0.
- intros.
  split.
  + intros.
    apply H.
    apply or_introl.
    apply H0.
  + intros.
    apply H.
    apply or_intror.
    apply H0.
Qed.

(** * PARTE 2 -- GALLINA E PROVAS *)
Require Import Coq.Strings.String.
Require Import Coq.Lists.List.
Require Import Coq.Arith.Plus.
Require Import Coq.Init.Nat.
Import ListNotations.

(** Um dicionário é uma coleção de registros
    indexados por uma chave. A chave é um
    número natural e o valor associado à
    chave é uma string. Aqui, estamos
    representando um dicionário como
    uma _árvore binária de busca_. *)

Inductive Tree {X : Type} : Type :=
  | leaf : Tree
  | node : X -> Tree -> Tree -> Tree.

Definition dic := @Tree (nat * string).

(** **** {0,5 pt.} Questão 3 *)
(** Defina uma função [clear] que, dado qualquer
    dicionário [d], retorna um dicionário vazio
    (i.e., uma folha). *)
Definition clear (d : dic) : dic := leaf.

(** **** {1,0 pt.} Questão 4 *)
(** Defina uma função [insert] que, dada uma
    chave [k], um valor [v] e um dicionário [d],
    atualiza o dicionário [d] da seguinte forma:
    - se já existir uma entrada mapeada em [k],
      a função atualiza o mapeamento para [v];
    - se não existir uma entrada mapeada em [k],
      a função insere o par [(k,v)] no
      dicionário.
      
    _Importante_: como uma árvore binária de
    busca, dado um nó com chave [x],
    seus descendentes à esquerda devem ser [< x],
    e seus descendentes à direita devem ser [> x].*)
Fixpoint insert (k : nat) (v : string) (d : dic) : dic :=
  match d with
  | leaf => node (k,v) leaf leaf
  | node (k',v') l r => if k =? k' then node (k, v) l r
                        else if k' <? k then node (k',v') (insert k v l) r
                        else node (k',v') l (insert k v r)
  end.

(** **** {0,5 pt.} Questão 5 *)
(** Defina uma função [get] que, dada uma chave
    [k] e um dicionário [k], retorna [Some v]
    se [v] estiver mapeado à [k], ou [None]
    se não existir nenhuma entrada associada
    à [k]. Esta função consiste em realizar
    uma busca binária no dicionário. *)
Fixpoint get (k : nat) (d : dic) : option string :=
  match d with
  | leaf => None
  | node (k',v') l r => if k =? k' then Some v'
                        else if k' <? k then get k l
                        else get k r
  end.

(** **** {0,5 pt.} Questão 6 *)
(** Defina uma função [get_keys] que, dado um
    dicionário [d], retorna uma lista de naturais
    com todas as chaves presentes no dicionário.
    A árvore deve ser percorrida _em ordem_. *)
Fixpoint get_keys (d : dic) : list nat :=
  match d with
  | leaf => []
  | node (k,v) l r => (get_keys l) ++ [k] ++ (get_keys r)
  end.

(** **** {0,5 pt.} Questão 7 *)
(** Defina uma função [size] que, dado um
    dicionário [d], retorna a quantidade de
    elementos no dicionário. _Importante_:
    esta função _não_ deve ser recursiva. *)
Definition size (d : dic) : nat := length (get_keys d).

(** **** {0,5 pt.} Questão 8 *)
(** Prove o seguinte teorema. *)
Theorem clear_all :
  forall (d : dic), clear d = leaf.
Proof.
intros.
unfold clear.
reflexivity.
Qed.

(** **** {0,5 pt.} Questão 9 *)
(** Prove o seguinte teorema. *)
Theorem get_keys_empty :
  forall (d : dic), d = leaf -> get_keys d = [].
Proof.
intros.
rewrite H.
simpl.
reflexivity.
Qed.

Check app_length.

(** **** {3,0 pt.} Questão 10 *)
(** Prove o seguinte teorema. Talvez você precise das
    táticas [destruct (exp) eqn:H] e [symmetry], além
    dos teoremas [app_length], [plus_assoc] e
    [plus_comm]. Em relação a este último teorema,
    talvez seja necessário especializá-lo fazendo
    [plus_comm _ 1]. *)
Theorem size_insert :
  forall (d : dic) (k : nat) (v : string),
    get k d = None ->
    size (insert k v d) = size d + 1.
Proof.
intros.
induction d.
- simpl. unfold size. simpl. reflexivity.
- destruct x as [k' v'].
  destruct (k =? k') eqn: H2.
  + simpl in H. rewrite H2 in H. inversion H.
  + destruct (k' <? k) eqn: H3.
      {
      simpl in H.
      rewrite H2 in H. rewrite H3 in H.
      assert (Ha := IHd1 H).
      simpl. rewrite H2. rewrite H3.
      }
      {
      simpl in H.
      rewrite H2 in H. rewrite H3 in H.
      assert (Ha := IHd2 H).
      simpl. rewrite H2. rewrite H3. unfold size. simpl.
      }
Qed.

















